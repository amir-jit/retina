//go:build experimental

package pktmon

import (
	"context"
	"errors"
	"fmt"

	v1 "github.com/cilium/cilium/pkg/hubble/api/v1"
	kcfg "github.com/microsoft/retina/pkg/config"
	"github.com/microsoft/retina/pkg/enricher"
	"github.com/microsoft/retina/pkg/log"
	"github.com/microsoft/retina/pkg/metrics"
	"github.com/microsoft/retina/pkg/plugin/api"
	"github.com/microsoft/retina/pkg/utils"
	"go.uber.org/zap"
)

var (
	ErrEnricherIsNil error = fmt.Errorf("enricher is nil")
)

const (
	Name       = "pktmon"
	srcIPKey   = "srcIP"
	dstIPKey   = "dstIP"
	srcPortKey = "srcPort"
	dstPortKey = "dstPort"
	protoKey   = "proto"
)

type PktMonPlugin struct {
	enricher        enricher.EnricherInterface
	externalChannel chan *v1.Event
	pkt             PktMon
	l               *log.ZapLogger
}

func (p *PktMonPlugin) Compile(ctx context.Context) error {
	return nil
}

func (p *PktMonPlugin) Generate(ctx context.Context) error {
	return nil
}

func (p *PktMonPlugin) Init() error {
	p.pkt = &WinPktMon{}

	return nil
}

func (p *PktMonPlugin) Name() string {
	return "pktmon"
}

func (p *PktMonPlugin) SetupChannel(ch chan *v1.Event) error {
	p.externalChannel = ch
	return nil
}

func New(cfg *kcfg.Config) api.Plugin {
	l := log.Logger().Named(string(Name))
	return &PktMonPlugin{
		pkt: &WinPktMon{
			l: l,
		},
		l: l,
	}
}

func (p *PktMonPlugin) Start(ctx context.Context) error {
	p.l.Info("setting up enricher since pod level is enabled")
	p.enricher = enricher.Instance()
	if p.enricher == nil {
		return fmt.Errorf("Failed to set up enricher: %w", ErrEnricherIsNil)
	}

	// calling packet capture routine concurrently
	p.l.Info("Initializing packet capture")
	err := p.pkt.Initialize()
	if err != nil {
		return fmt.Errorf("Failed to initialize pktmon: %w", err)
	}

	for {
		packet, metadata, err := p.pkt.GetNextPacket()
		if errors.Is(err, ErrNotSupported) {
			p.l.Error("Failed to get packet", zap.Error(err))
			continue
		}

		if err != nil {
			p.l.Error("Error getting packet", zap.Error(err))
			continue
		}

		fl := utils.ToFlow(
			metadata.Timestamp, // timestamp
			packet.SourceIP,
			packet.DestIP,
			packet.SourcePort,
			packet.DestPort,
			packet.Protocol,
			metadata.ComponentID, // observationPoint
			metadata.Verdict,     // flow.Verdict
			metadata.DropReason,  // flow.Direction
		)

		if fl == nil {
			p.l.Error("Flow generated by ToFlow is nil", zap.String(srcIPKey, packet.SourceIP.String()), zap.Uint32(srcPortKey, packet.SourcePort), zap.String(dstIPKey, packet.DestIP.String()), zap.Uint32(dstPortKey, packet.DestPort), zap.Uint8(protoKey, packet.Protocol))
			continue
		}

		utils.AddPacketSize(fl, metadata.PayloadLength)

		utils.AddTcpFlags(fl, packet.syn, packet.ack, packet.fin, packet.rst, packet.psh, packet.urg)

		ev := &v1.Event{
			Event:     fl,
			Timestamp: fl.Time,
		}
		if p.enricher != nil {
			p.enricher.Write(ev)
		}

		// Write the event to the external channel.
		if p.externalChannel != nil {
			select {
			case p.externalChannel <- ev:
			default:
				// Channel is full, drop the event.
				// We shouldn't slow down the reader.
				metrics.LostEventsCounter.WithLabelValues(utils.ExternalChannel, string(Name)).Inc()
			}
		}
	}
}

func (p *PktMonPlugin) Stop() error {
	return nil
}
